---
title: "Getting started"
author: "Nick McManus"
date: "6/17/2022"
output: html_document
---

## Data:

The data used in this tutorial were obtained from the Introduction to Marxan course. Specifically, the data were originally a subset of a larger spatial prioritization project performed under contract to Australia’s Department of Environment and Water Resources (Klein et al. 2007).

Note: you need a license to install gurobi and solve for the problem. Free academic licenses are available, and you must be signed in through university network (or VPN) for it to successfully work. Go to https://cran.r-project.org/web/packages/prioritizr/vignettes/gurobi_installation.html for details on installation.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# load packages
library(prioritizrdata)
library(prioritizr)
library(vegan)
library(cluster)
library(gurobi)

# load planning unit data
data(tas_pu)

# load feature data
data(tas_features)
```

The `tas_pu` object contains planning units represented as spatial polygons. This object has three columns that denote the following informaiton for each planning unit: a unique identifier (`id`), unimproved land value (`cost`), and current conservation status (`locked_in`). Planning units that have at least half of their area overlapping with existing prtected areas are denoted with a locked in value of 1; otherwise, they are denoted with a value of 0.  

Looking at the planning unit data, we can see that the units correspond to hexagonal land parcels. There is also a clear spatial pattern in the cost and conservation status. 

```{r}
# print planning unit data
print(tas_pu)
```

```{r}
# plot map of planning unit costs
plot(st_as_sf(tas_pu[, "cost"]), main = "Planning unit costs")
```

```{r}
# plot map of planning unit coverage by protected areas
plot(st_as_sf(tas_pu[, "locked_in"]), main = "Protected area coverage")
```

The `tas_features` object describes the spatial distribution of the features. These data are expressed as a stack of 62 rasters, each layer in the stack corresponding to one of 62 different vegetation communities. Each layer contains a spatially references grid of rectangular cells, which have information on the distribution of the given vegetation community. Specifically, these grid cells are assigned a value of 1 if the vegetation community is present and a value of 0 if absent. 

First we plot the first four features as an example. Pixel values denote the presence or absence of each feature within the extent of the study area. 

```{r}
# print planning unit data
print(tas_features)
```

```{r}
# plot map of the first four vegetation classes
plot(tas_features[[1:4]], main = paste("Feature", 1:4))
```
"The planning units in this tutorial are stored as spatial polygons. Although spatial polygons provide considerable flexibility in the shape and size of the planning units, such flexibility comes at a cost. This is because the spatial data processing routines needed to combine spatial polygon data and raster data for optimization can be very computationally expensive (e.g., calculating zonal statistics). As a consequence, we generally recommend using raster-based planning unit data where possible to reduce processing time. Another strategy is to complete spatial data processing routines manually using other software (e.g., ESRI ArcGIS) and use the pre-processed data directly with the prioritizr R package."


## Problem formulation

Now we will formulate a conservation planing problem. To achieve this, we first specify which objects contain the planning unit and feature data (using the `problem()` function). Next, we specify that we want to use the minimum set objective function (using the `add_min_set_objective()` function). This objective function indicates that we wish to minimize the total cost of planning units selected by the prioritization. We then specify boundary penalties reduce spatial fragmentation in the resulting prioritization (using the `add_boundary_penalties()` function; see the Calibrating trade-offs vignette for details on calibrating the penalty value). We also specify representation targets to ensure the resulting prioritization provides adequate coverage of each vegetation community (using the add_relative_targets() function). Specifically, we specify targets to ensure at least 17% of the spatial extent of each vegetation community (based on the Aichi Target 11). Additionally, we set constraints to ensure that planning units predominately covered by existing protected areas are selected by the prioritization (using the add_locked_in_constraints() function). Finally, we specify that the prioritization should either select – or not select – planning units for prioritization (using the add_binary_decisions() function).

```{r}
# build problem

# specify which objects contain the planning unit and feature data
p1 <- problem(tas_pu, tas_features, cost_column = "cost") %>%
  # minimize total cost
  add_min_set_objective() %>% 
  # specify boundary penalty
  add_boundary_penalties(penalty = 0.005) %>% 
  # specify targets of at least 17% of spatial extent
  add_relative_targets(0.17) %>% 
  add_locked_in_constraints("locked_in") %>% 
  add_binary_decisions()
  
# print the problem
print(p1)
  
```


## Prioritization

We can now solve the problem formulation (`p1`) to generate a prioritization (using the `solve()` function). The prioritizr R package supports a range of different exact algorithm solvers, including Gurobi, IBM CPLEX, CBC, Rsymphony, and lpsymphony. Although there are benefits and limitations associated with each of these different solvers, they should return similar results. Note that you will need at least one solver installed on your system to generate prioritizations. Since we did not specify a solver when building the problem, the prioritizr R package will automatically select the best available solver installed. We recommend using the Gurobi solver if possible, and have used it for this tutorial (see the Gurobi Installation Guide vignette for installation instructions). After solving the problem, the prioritization will be stored in the `solution_1` column of the `s1` object.

```{r}
# solve problem
s1 <- solve(p1)

```

```{r}
# plot map of prioritization
plot(st_as_sf(s1[, "solution_1"]), main = "Prioritization",
     pal = c("grey90", "darkgreen"))
```










